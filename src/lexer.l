%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "parser.tab.h"  // This will include the token definitions from the parser (generated by Bison)
%}

%%

/* Keywords */
"if"                { return IF; }
"else"              { return ELSE; }
"elif"              { return ELIF; }
"while"             { return WHILE; }
"int"               { return INT; }
"float"             { return FLOAT; }
"return"            { return RETURN; }
"print"             { return PRINT; }
"Zahid"             { return ZAHID; }
"stop"              { return STOP; }
"end"               { return END; }
"maax"              { return MAAX; }
"miin"              { return MIIN; }
"Case"              { return CASE; }
"answer"            { return ANSWER; }
"floop"             { return FLOOP; }
"leapyr"            { return LEAPYR; }
"Toggle"            { return TOGGLE; }
"comm"              { return COMM; }
"Core"              { return CORE; }
"Result"            { return RESULT; }
"Dec"               { return DEC; }
"sqrt"              { return SQRT; }
"gcd"               { return GCD; }
"lcm"               { return LCM; }
"excg"              { return EXCG; }
"text"              { return TEXT; }
"info"              { return INFO; }
"preset"            { return PRESET; }

/* Identifiers */
[a-zA-Z_][a-zA-Z0-9_]* {
    yylval.str = strdup(yytext); // Store the identifier as a string
    return IDENTIFIER;
}

/* Constants (integers and floating-point numbers) */
[0-9]+                { return NUMBER; }
[0-9]*"."[0-9]+       { return FLOAT_NUMBER; }

/* Operators */
"="                   { return ASSIGN; }
"+"                   { return PLUS; }
"-"                   { return MINUS; }
"*"                   { return MUL; }
"/"                   { return DIV; }
"%"                   { return MOD; }
"=="                  { return EQ; }
"!="                  { return NEQ; }
"<"                   { return LT; }
"<="                  { return LEQ; }
">"                   { return GT; }
">="                  { return GEQ; }

/* Parentheses and Brackets */
"("                   { return LPAREN; }
")"                   { return RPAREN; }
"{"                   { return LBRACE; }
"}"                   { return RBRACE; }

/* Semicolon */
";"                   { return SEMICOLON; }

/* Whitespace (ignore spaces, tabs, newlines) */
[ \t\n\r]+            { /* Ignore whitespace */ }

/* Comments */
"comm:"([^:]+)":comm"  { /* Ignore comments */ }

/* Handle unrecognized characters */
.                     { printf("Unknown character: %s\n", yytext); exit(1); }

%%

int yywrap() {
    return 1;
}

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <source-file>\n", argv[0]);
        return 1;
    }
    
    FILE *source = fopen(argv[1], "r");
    if (source == NULL) {
        perror("Error opening file");
        return 1;
    }

    yyin = source;  // Set the input for the lexer
    yylex();         // Start lexical analysis

    fclose(source);
    return 0;
}
